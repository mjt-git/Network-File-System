/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "IDL.h"

bool_t
xdr_timespec_IDL (XDR *xdrs, timespec_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_long (xdrs, &objp->tv_sec))
		 return FALSE;
	 if (!xdr_long (xdrs, &objp->tv_nsec))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_stat_IDL (XDR *xdrs, stat_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_uint32_t (xdrs, &objp->st_dev))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_ino))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_mode))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_nlink))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_uid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_gid))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_rdev))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_size))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_blksize))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->st_blocks))
		 return FALSE;
	 if (!xdr_timespec_IDL (xdrs, &objp->st_atim))
		 return FALSE;
	 if (!xdr_timespec_IDL (xdrs, &objp->st_mtim))
		 return FALSE;
	 if (!xdr_timespec_IDL (xdrs, &objp->st_ctim))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_fuse_file_info_IDL (XDR *xdrs, fuse_file_info_IDL *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->writepage))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->direct_io))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->keep_cache))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->flush))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nonseekable))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->cache_readdir))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->padding))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->flags);
		IXDR_PUT_U_LONG(buf, objp->writepage);
		IXDR_PUT_U_LONG(buf, objp->direct_io);
		IXDR_PUT_U_LONG(buf, objp->keep_cache);
		IXDR_PUT_U_LONG(buf, objp->flush);
		IXDR_PUT_U_LONG(buf, objp->nonseekable);
		IXDR_PUT_U_LONG(buf, objp->cache_readdir);
		IXDR_PUT_U_LONG(buf, objp->padding);
		}
		 if (!xdr_uint64_t (xdrs, &objp->fh))
			 return FALSE;
		 if (!xdr_uint64_t (xdrs, &objp->lock_owner))
			 return FALSE;
		 if (!xdr_uint32_t (xdrs, &objp->poll_events))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->flags))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->writepage))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->direct_io))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->keep_cache))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->flush))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->nonseekable))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->cache_readdir))
				 return FALSE;
			 if (!xdr_u_int (xdrs, &objp->padding))
				 return FALSE;

		} else {
		objp->flags = IXDR_GET_LONG(buf);
		objp->writepage = IXDR_GET_U_LONG(buf);
		objp->direct_io = IXDR_GET_U_LONG(buf);
		objp->keep_cache = IXDR_GET_U_LONG(buf);
		objp->flush = IXDR_GET_U_LONG(buf);
		objp->nonseekable = IXDR_GET_U_LONG(buf);
		objp->cache_readdir = IXDR_GET_U_LONG(buf);
		objp->padding = IXDR_GET_U_LONG(buf);
		}
		 if (!xdr_uint64_t (xdrs, &objp->fh))
			 return FALSE;
		 if (!xdr_uint64_t (xdrs, &objp->lock_owner))
			 return FALSE;
		 if (!xdr_uint32_t (xdrs, &objp->poll_events))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->flags))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->writepage))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->direct_io))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->keep_cache))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flush))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->nonseekable))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->cache_readdir))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->padding))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->fh))
		 return FALSE;
	 if (!xdr_uint64_t (xdrs, &objp->lock_owner))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->poll_events))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_getattr_IDL (XDR *xdrs, getattr_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->statbuf, sizeof (stat_IDL), (xdrproc_t) xdr_stat_IDL))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_mkdir_IDL (XDR *xdrs, mkdir_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->mode))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rmdir_IDL (XDR *xdrs, rmdir_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_open_IDL (XDR *xdrs, open_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->fi, sizeof (fuse_file_info_IDL), (xdrproc_t) xdr_fuse_file_info_IDL))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_read_IDL (XDR *xdrs, read_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->buf, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->fi, sizeof (struct fuse_file_info), (xdrproc_t) xdr_fuse_file_info))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_write_IDL (XDR *xdrs, write_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->buf, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->fi, sizeof (struct fuse_file_info), (xdrproc_t) xdr_fuse_file_info))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_opendir_IDL (XDR *xdrs, opendir_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->fi, sizeof (fuse_file_info_IDL), (xdrproc_t) xdr_fuse_file_info_IDL))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_readdir_IDL (XDR *xdrs, readdir_IDL *objp)
{
	register int32_t *buf;

	 if (!xdr_pointer (xdrs, (char **)&objp->path, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->buf, sizeof (char), (xdrproc_t) xdr_char))
		 return FALSE;
	 if (!xdr_uint32_t (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_pointer (xdrs, (char **)&objp->fi, sizeof (fuse_file_info_IDL), (xdrproc_t) xdr_fuse_file_info_IDL))
		 return FALSE;
	return TRUE;
}
