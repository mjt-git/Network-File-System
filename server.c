/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#define _FILE_OFFSET_BITS  64

#include "IDL.h"
#include <stdio.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/xattr.h>
#include <fuse.h>
#include <pthread.h>
#include <time.h>

#include <openssl/sha.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>



#define SPLIT_S_ADDR_INTO_BYTES(s_addr) \
    ((s_addr) >> 24) & 0xFF, \
    ((s_addr) >> 16) & 0xFF, \
    ((s_addr) >>  8) & 0xFF, \
    ((s_addr)      ) & 0xFF

const char * rootpath = "/home/localadmin/finalproject/serverpoint";

void print_client_ip(struct svc_req *rqstp){
	printf("client address: %hu.%hu.%hu.%hu ", SPLIT_S_ADDR_INTO_BYTES(ntohl(rqstp->rq_xprt->xp_raddr.sin_addr.s_addr)));
}

static void * getfullpath(char fpath[PATH_MAX], const char * path){
  strcpy(fpath, rootpath);
  strncat(fpath, path, PATH_MAX);
}

void print_getattr_IDL(getattr_ret_IDL res) {
	printf("\n");
	printf("************************\n");
	printf("result.res: %d\n", res.res);
	printf("result.st_dev: %u\n", res.st_dev);
	printf("result.st_ino: %u\n", res.st_ino);
	printf("result.st_mode: %ld\n", res.st_mode);
	printf("result.st_nlink: %u\n", res.st_nlink);
	printf("result.st_uid: %u\n", res.st_uid);
	printf("result.st_gid: %u\n", res.st_gid);
	printf("result.st_rdev: %u\n", res.st_rdev);
	printf("result.st_size: %u\n", res.st_size);
	printf("result.st_blksize: %u\n", res.st_blksize);
	printf("result.st_blocks: %u\n", res.st_blocks);
	printf("result.st_atim: %u\n", res.st_atim);
	printf("result.st_mtim: %u\n", res.st_mtim);
	printf("result.st_ctim: %u\n", res.st_ctim);
	printf("************************\n");
	printf("\n");
}

void print_fgetattr_ret_IDL(fgetattr_ret_IDL res) {
	printf("\n");
	printf("************************\n");
	printf("result.res: %d\n", res.res);
	printf("result.st_dev: %u\n", res.st_dev);
	printf("result.st_ino: %u\n", res.st_ino);
	printf("result.st_mode: %ld\n", res.st_mode);
	printf("result.st_nlink: %u\n", res.st_nlink);
	printf("result.st_uid: %u\n", res.st_uid);
	printf("result.st_gid: %u\n", res.st_gid);
	printf("result.st_rdev: %u\n", res.st_rdev);
	printf("result.st_size: %u\n", res.st_size);
	printf("result.st_blksize: %u\n", res.st_blksize);
	printf("result.st_blocks: %u\n", res.st_blocks);
	printf("result.st_atim: %u\n", res.st_atim);
	printf("result.st_mtim: %u\n", res.st_mtim);
	printf("result.st_ctim: %u\n", res.st_ctim);
	printf("************************\n");
	printf("\n");
}

void print_function_name(const char * name, struct svc_req *rqstp) {
	time_t current;
    time(&current);
    struct tm *current_tmp = localtime(&current);
    char s[100];
    strftime(s, sizeof(s), "%04Y/%02m/%02d %H:%M:%S", current_tmp);
	printf("\n*******************\nfuction %s is invoked by ", name);
	print_client_ip(rqstp);
	printf("at %s\n",s);
	printf("*******************\n");
}

getattr_ret_IDL *
getattr_1000_svc(getattr_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("getattr_10_svc",rqstp);

	static getattr_ret_IDL result;
	int res;
	struct stat * statbuf = (struct stat*)malloc(sizeof(struct stat));
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	// printf("argp->path: %s\n", argp->path);
	// printf("full path is %s\n", fpath);
	res = lstat(fpath, statbuf);

	if(res == 0){
	  result.res = res;
	} else{
	  result.res = -errno;
	}
	result.st_dev = statbuf->st_dev;
	result.st_ino = statbuf->st_ino;
	result.st_mode = statbuf->st_mode;
	result.st_nlink = statbuf->st_nlink;
	result.st_uid = statbuf->st_uid;
	result.st_gid = statbuf->st_gid;
	result.st_rdev = statbuf->st_rdev;
	result.st_size = statbuf->st_size;
	result.st_blksize = statbuf->st_blksize;
	result.st_blocks = statbuf->st_blocks;
	result.st_atim = statbuf->st_atime;
	result.st_mtim = statbuf->st_mtime;
	result.st_ctim = statbuf->st_ctime;
	
	//print_getattr_IDL(result);

	free(statbuf);
	return &result;
}

int *
mkdir_1000_svc(mkdir_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("mkdir_10_svc",rqstp);

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	//printf("argp->path is: %s\n", argp->path);
	//printf("argp->path_p is: %s\n", *argp->path_p);
	//printf("%s, mode is %3o\n", fpath, argp->mode);
	//uint32_t fmode = argp->mode & 0777;
    result = mkdir(fpath, argp->mode);
	//printf("mkdir result is: %d\n", result);
	
	return &result;
}

int *
rmdir_1000_svc(rmdir_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("rmdir_10_svc",rqstp);
	
	static int  result;
	char fpath[PATH_MAX];
        getfullpath(fpath, argp->path);
        //printf("remove %s\n", fpath);
        //uint32_t fmode = argp->mode & 0777;                                                                    
        result = rmdir(fpath);
        //printf("result is %d\n", result);

	return &result;
}

int *
open_1000_svc(open_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("open_1000_svc",rqstp);

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	//printf("fpath: %s\n", fpath);
	//printf("argp->flags: %d\n", argp->flags);
	result = open(fpath, argp->flags);	
	//printf("open call result: %d\n", result);
	
	return &result;
}

struct read_ret_IDL *
read_1000_svc(read_IDL *argp, struct svc_req *rqstp)
{
  //print_function_name("read_1000_svc",rqstp);
	static struct read_ret_IDL result;

	//printf("argp->fh: %d\n", argp->fh);
	//printf("argp->size: %u\n", argp->size);
	//printf("argp->offset: %d\n", argp->offset);

	char * buf = (char*)malloc(sizeof(char) * argp->size);
	result.count = pread(argp->fh, buf, argp->size, argp->offset);
	//printf("result.count: %d\n", result.count);
	memcpy(result.buf, buf, argp->size);

	//printf("buf readed: \n%s\n", result.buf);
	
	return &result;
}

int *
write_1000_svc(write_IDL *argp, struct svc_req *rqstp)
{
  	//print_function_name("write_1000_svc",rqstp);
	static int  result;
	
	//printf("to be written: %s\n", argp->buf);
	//printf("fh is %d\n", argp->fh);
	result = pwrite(argp->fh, argp->buf, argp->size, argp->offset);
	// printf("pwrite return %d\n", result);
	return &result;
}

struct opendir_ret_IDL *
opendir_1000_svc(opendir_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("opendir_1000_svc",rqstp);

	static struct opendir_ret_IDL result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	//printf("full path is: %s\n", fpath);
	DIR * dp;
	dp = opendir(fpath);
	result.isvalid = (dp == NULL) ? 0 : 1;   // 0 -> invalid; 1 -> valid
	result.res = dirfd(dp);
	//printf("is valid: %d; dp is %ld\n", result.isvalid, (intptr_t)dp);
	return &result;
}

struct readdir_ret_IDL *
readdir_1000_svc(readdir_IDL *argp, struct svc_req *rqstp)
{
	//printf("[readdir_1000_svc]: start\n");
	void * buf = (void*)malloc(sizeof(char) * 65535);
	// 	memset(buf, 0, 65535);
	static readdir_ret_IDL response;
	int retstat = 0;
	DIR *dp;
	struct dirent *de;

	dp = fdopendir(argp->fh);

	//printf("arg->fh=%ld\n",argp->fh);
	//syscall readdir
	de = readdir(dp);
	//printf("after readdir call\n");
    if (de == 0) {
        // retstat = log_error("bb_readdir readdir");
        printf("error: readdir ");
        return &response;
    }

    //printf("*****de->d_d_name=%s\n",de->d_name);
    int length = 0;
    int count = 0;
    char * curr = buf;
    do {
      //printf("calling filler with name %s\n", de->d_name);
      memcpy(curr, de->d_name, strlen(de->d_name));
      const char * zero = "\0";
      memcpy(curr+strlen(de->d_name), zero, 1);
      length += strlen(de->d_name) + 1;
      curr += strlen(de->d_name) + 1;
      count += 1;
    } while ((de = readdir(dp)) != NULL);
    //int off = 0;
    //for(int i = 0; i < count; i++){
      //printf("%s\n", (char*)(buf + off));
      //off += strlen(buf + off) + 1;
    //}
    //printf("[readdir_1000_svc]: end with retstat=%d, buf is: %p\n",retstat, buf);
    response.res = retstat;
    memmove(response.buf, buf, length);
    response.length = length;
    response.count = count;
    //off = 0;
    //for(int i = 0; i < count; i++){
      //printf("%s\n", (char*)(response.buf + off));
      //off += strlen(response.buf + off) + 1;
    //}
    //printf("res buf is: %s\n", response.buf);
    return &response;
}

void *
hellotest_1000_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	printf("[hellotest_1000_svc]successfully connected to ");
	print_client_ip(rqstp);
	return (void *) &result;
}

int *
access_1000_svc(access_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("access_1000_svc",rqstp);

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	//printf("argp->path is: %s\n", argp->path);
	//printf("fpath is: %s\n", fpath);

	result = access(fpath, argp->mask);
	//printf("access function result: %d", result);
	return &result;
}

int *
releasedir_1000_svc(releasedir_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("releasedir_1000_svc",rqstp);
	static int result = 0;

	DIR * dp;
	dp = fdopendir(argp->fh);
	closedir(dp);

	return &result;
}

int *
release_1000_svc(release_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("release_1000_svc",rqstp);
	static int result;

	result = close(argp->fh);
	//printf("close function result: %d\n", result);

	return &result;
}

struct fgetattr_ret_IDL *
fgetattr_1000_svc(fgetattr_IDL *argp, struct svc_req *rqstp)
{
	static struct fgetattr_ret_IDL result;

	struct stat * statbuf = (struct stat *)malloc(sizeof(struct stat));
	result.res = fstat(argp->fh, statbuf);

	result.st_dev = statbuf->st_dev;
	result.st_ino = statbuf->st_ino;
	result.st_mode = statbuf->st_mode;
	result.st_nlink = statbuf->st_nlink;
	result.st_uid = statbuf->st_uid;
	result.st_gid = statbuf->st_gid;
	result.st_rdev = statbuf->st_rdev;
	result.st_size = statbuf->st_size;
	result.st_blksize = statbuf->st_blksize;
	result.st_blocks = statbuf->st_blocks;
	result.st_atim = statbuf->st_atime;
	result.st_mtim = statbuf->st_mtime;
	result.st_ctim = statbuf->st_ctime;

	//print_fgetattr_ret_IDL(result);

	free(statbuf);
	return &result;
}

int *
mknod_1000_svc(mknod_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("mknod_1000_svc",rqstp);
	static int result;

	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	int mode = argp->mode;
	int dev = argp->dev;

	if (S_ISREG(mode)) {
		result = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
		if (result >= 0){
		    result = close(result);
		}
    } else {
		if (S_ISFIFO(mode)) {
			result = mkfifo(fpath, mode);
		}
		else {
			result = mknod(fpath, mode, dev);
		}
    }

	return &result;
}

int *
truncate_1000_svc(truncate_IDL * argp, struct svc_req *rqstp){
  static int result;
  char fpath[PATH_MAX];
  getfullpath(fpath, argp->path);
  int newsize = argp->newsize;
  result = truncate(fpath, newsize);
  return &result;
}

int *
ftruncate_1000_svc(ftruncate_IDL * argp, struct svc_req *rqstp){
  static int result;
  //char fpath[PATH_MAX];
  //getfullpath(fpath, argp->path);
  //int newsize = argp->newsize;
  result = ftruncate(argp->fh, argp->newsize);
  return &result;
}

int *
unlink_1000_svc(unlink_IDL * argp, struct svc_req *rqstp){
	//print_function_name("unlink_1000_svc",rqstp);
	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath,argp->path);
	//printf("fpath=%s\n",fpath);
	result = unlink(fpath);
	//printf("result=%d\n",result);
	return &result;
}

struct utime_ret_IDL *
utime_1000_svc(utime_IDL *argp, struct svc_req *rqstp)
{
	//print_function_name("utime_1000_svc",rqstp);
	static struct utime_ret_IDL result;

	char fpath[PATH_MAX];
	getfullpath(fpath,argp->path);
	struct utimbuf * ubuf = (struct utimbuf * )malloc(sizeof(struct utimbuf));

	int res = utime(fpath, ubuf);
	result.actime = ubuf->actime;
	result.modtime = ubuf->modtime;
	result.res = (res == 0) ? 0 : -errno;

	free(ubuf);
	return &result;
}

int *
rename_1000_svc(rename_IDL *argp, struct svc_req *rqstp)
{
	static int result;

	char fpath[PATH_MAX];
	getfullpath(fpath,argp->path);
	char newfpath[PATH_MAX];
	getfullpath(newfpath,argp->newpath);

	int res = rename(fpath, newfpath);
	result = (res == 0) ? 0 : -errno;

	return &result;
}

int *
chmod_1000_svc(chmod_IDL *argp, struct svc_req *rqstp)
{
	static int result;

	char fpath[PATH_MAX];
	getfullpath(fpath,argp->path);

	int res = chmod(fpath, argp->mode);
	result = (res == 0) ? 0 : -errno;

	return &result;
}


int *
chown_1000_svc(chown_IDL *argp, struct svc_req *rqstp)
{
	static int result;

	char fpath[PATH_MAX];
	getfullpath(fpath,argp->path);

	int res = chown(fpath, argp->uid, argp->gid);
	result = (res == 0) ? 0 : -errno;

	return &result;
}


int *
authenticate_1000_svc(authenticate_IDL *argp, struct svc_req *rqstp)
{	
	static int result;
	print_function_name("authenticate_1000_svc",rqstp);
	unsigned int  hashvalue = argp->hash;
	unsigned int truevalue;
	FILE *fptr;
    if ((fptr = fopen("password", "r")) == NULL) {
        printf("Error! cannot open the password file\n");
        exit(1);
    }
    fscanf(fptr, "%d", &truevalue);
    fclose(fptr);
	result = (hashvalue == truevalue)? 0:1;
	if(result==0){
		printf("passwords match\n");
	}else{
		printf("passwords don't match.\n");
	}
	print_client_ip(rqstp);
	return &result;
}

int * fdatasync_1000_svc(fdatasync_IDL *argp, struct svc_req *rqstp){
  static int result;
  result = fdatasync(argp->fh);
  return &result;
}

int * fsync_1000_svc(fsync_IDL *argp, struct svc_req *rqstp){
  static int result;
  result = fsync(argp->fh);
  return &result;
}
