/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#define _FILE_OFFSET_BITS  64

#include "IDL.h"
#include <stdio.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/xattr.h>
#include  <fuse.h>

const char * rootpath = "/home/localadmin/finalproject/bbfs_server/serverpoint";

// typedef int(* 	fuse_fill_dir_t) (void *buf, const char *name, const struct stat *stbuf, off_t off, enum fuse_fill_dir_flags flags);

static void * getfullpath(char fpath[PATH_MAX], const char * path){
  strcpy(fpath, rootpath);
  strncat(fpath, path, PATH_MAX);
}

void print_getattr_IDL(getattr_IDL res) {
	printf("\n");
	printf("************************\n");
	printf("result.res: %d\n", res.res);
	printf("result.path: %s\n", res.path);
	printf("result.st_dev: %u\n", res.st_dev);
	printf("result.st_ino: %u\n", res.st_ino);
	printf("result.st_mode: %ld\n", res.st_mode);
	printf("result.st_nlink: %u\n", res.st_nlink);
	printf("result.st_uid: %u\n", res.st_uid);
	printf("result.st_gid: %u\n", res.st_gid);
	printf("result.st_rdev: %u\n", res.st_rdev);
	printf("result.st_size: %u\n", res.st_size);
	printf("result.st_blksize: %u\n", res.st_blksize);
	printf("result.st_blocks: %u\n", res.st_blocks);
	printf("result.st_atim: %u\n", res.st_atim);
	printf("result.st_mtim: %u\n", res.st_mtim);
	printf("result.st_ctim: %u\n", res.st_ctim);
	printf("************************\n");
	printf("\n");
}

void print_fgetattr_ret_IDL(fgetattr_ret_IDL res) {
	printf("\n");
	printf("************************\n");
	printf("result.res: %d\n", res.res);
	printf("result.st_dev: %u\n", res.st_dev);
	printf("result.st_ino: %u\n", res.st_ino);
	printf("result.st_mode: %ld\n", res.st_mode);
	printf("result.st_nlink: %u\n", res.st_nlink);
	printf("result.st_uid: %u\n", res.st_uid);
	printf("result.st_gid: %u\n", res.st_gid);
	printf("result.st_rdev: %u\n", res.st_rdev);
	printf("result.st_size: %u\n", res.st_size);
	printf("result.st_blksize: %u\n", res.st_blksize);
	printf("result.st_blocks: %u\n", res.st_blocks);
	printf("result.st_atim: %u\n", res.st_atim);
	printf("result.st_mtim: %u\n", res.st_mtim);
	printf("result.st_ctim: %u\n", res.st_ctim);
	printf("************************\n");
	printf("\n");
}

void print_function_name(const char * name) {
	printf("\n*******************\n");
	printf("INSIDE %s\n", name);
	printf("*******************\n");
}

getattr_IDL *
getattr_1000_svc(getattr_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("getattr_10_svc");

	static getattr_IDL result;
	int res;
	struct stat * statbuf = (struct stat*)malloc(sizeof(struct stat));
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path: %s\n", argp->path);
	printf("full path is %s\n", fpath);
	res = lstat(fpath, statbuf);

	result.path = "xx";
	if(res == 0){
	  result.res = res;
	} else{
	  result.res = -errno;
	}
	result.st_dev = statbuf->st_dev;
	result.st_ino = statbuf->st_ino;
	result.st_mode = statbuf->st_mode;
	result.st_nlink = statbuf->st_nlink;
	result.st_uid = statbuf->st_uid;
	result.st_gid = statbuf->st_gid;
	result.st_rdev = statbuf->st_rdev;
	result.st_size = statbuf->st_size;
	result.st_blksize = statbuf->st_blksize;
	result.st_blocks = statbuf->st_blocks;
	result.st_atim = statbuf->st_atime;
	result.st_mtim = statbuf->st_mtime;
	result.st_ctim = statbuf->st_ctime;
	
	print_getattr_IDL(result);

	free(statbuf);
	return &result;
}

int *
mkdir_1000_svc(mkdir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("mkdir_10_svc");

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path is: %s\n", argp->path);
	//printf("argp->path_p is: %s\n", *argp->path_p);
	printf("%s, mode is %3o\n", fpath, argp->mode);
	//uint32_t fmode = argp->mode & 0777;
    result = mkdir(fpath, argp->mode);
	printf("mkdir result is: %d\n", result);
	
	return &result;
}

int *
rmdir_1000_svc(rmdir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("rmdir_10_svc");
	
	static int  result;
	char fpath[PATH_MAX];
        getfullpath(fpath, argp->path);
        printf("remove %s\n", fpath);
        //uint32_t fmode = argp->mode & 0777;                                                                    
        result = rmdir(fpath);
        printf("result is %d\n", result);

	return &result;
}

int *
open_1000_svc(open_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("open_1000_svc");

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("fpath: %s\n", fpath);
	printf("argp->flags: %d\n", argp->flags);
	result = open(fpath, argp->flags);	
	printf("open call result: %d\n", result);
	
	return &result;
}

struct read_ret_IDL *
read_1000_svc(read_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("read_1000_svc");
	static struct read_ret_IDL result;

	printf("argp->fh: %d\n", argp->fh);
	printf("argp->size: %u\n", argp->size);
	printf("argp->offset: %d\n", argp->offset);

	char * buf = (char*)malloc(sizeof(char) * argp->size);
	result.count = pread(argp->fh, buf, argp->size, argp->offset);
	printf("result.count: %d\n", result.count);
	memcpy(result.buf, buf, argp->size);

	printf("buf readed: \n%s\n", result.buf);
	
	return &result;
}

struct write_IDL*
write_1000_svc(write_IDL *argp, struct svc_req *rqstp)
{
	static int  result;
	static write_IDL res;
	/*
	 * insert server code here
	 */

	return &res;
}

struct opendir_ret_IDL *
opendir_1000_svc(opendir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("opendir_1000_svc");

	static struct opendir_ret_IDL result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("full path is: %s\n", fpath);
	DIR * dp;
	dp = opendir(fpath);
	result.isvalid = (dp == NULL) ? 0 : 1;   // 0 -> invalid; 1 -> valid
	result.res = dirfd(dp);
	printf("is valid: %d; dp is %ld\n", result.isvalid, (intptr_t)dp);
	return &result;
}

struct readdir_ret_IDL *
readdir_1000_svc(readdir_IDL *argp, struct svc_req *rqstp)
{
	printf("[readdir_1000_svc]: start\n");
	void * buf = (void*)malloc(sizeof(char) * 65535);
	// 	memset(buf, 0, 65535);
	static readdir_ret_IDL response;
	int retstat = 0;
	DIR *dp;
	struct dirent *de;

	dp = fdopendir(argp->fh);

	printf("arg->fh=%ld\n",argp->fh);
	//syscall readdir
	de = readdir(dp);
	printf("after readdir call\n");
    if (de == 0) {
        // retstat = log_error("bb_readdir readdir");
        printf("error: readdir ");
        return &response;
    }

    printf("*****de->d_d_name=%s\n",de->d_name);
    int length = 0;
    int count = 0;
    char * curr = buf;
    do {
      printf("calling filler with name %s\n", de->d_name);
      memcpy(curr, de->d_name, strlen(de->d_name));
      const char * zero = "\0";
      memcpy(curr+strlen(de->d_name), zero, 1);
      length += strlen(de->d_name) + 1;
      curr += strlen(de->d_name) + 1;
      count += 1;
    } while ((de = readdir(dp)) != NULL);
    int off = 0;
    for(int i = 0; i < count; i++){
      printf("%s\n", (char*)(buf + off));
      off += strlen(buf + off) + 1;
    }
    printf("[readdir_1000_svc]: end with retstat=%d, buf is: %p\n",retstat, buf);
    response.res = retstat;
    memmove(response.buf, buf, length);
    response.length = length;
    response.count = count;
    off = 0;
    for(int i = 0; i < count; i++){
      printf("%s\n", (char*)(response.buf + off));
      off += strlen(response.buf + off) + 1;
    }
    //printf("res buf is: %s\n", response.buf);
    return &response;
}

void *
hellotest_1000_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	printf("*****************************\n");
	printf("HELLO!!!!!!!!!!!!!\n");
	printf("*****************************\n");
	return (void *) &result;
}

int *
access_1000_svc(access_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("access_1000_svc");

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path is: %s\n", argp->path);
	printf("fpath is: %s\n", fpath);

	result = access(fpath, argp->mask);
	printf("access function result: %d", result);
	return &result;
}

int *
releasedir_1000_svc(releasedir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("releasedir_1000_svc");
	static int result = 0;

	DIR * dp;
	dp = fdopendir(argp->fh);
	closedir(dp);

	return &result;
}

int *
release_1000_svc(release_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("release_1000_svc");
	static int result;

	result = close(argp->fh);
	printf("close function result: %d\n", result);

	return &result;
}

struct fgetattr_ret_IDL *
fgetattr_1000_svc(fgetattr_IDL *argp, struct svc_req *rqstp)
{
	static struct fgetattr_ret_IDL result;

	struct stat * statbuf = (struct stat *)malloc(sizeof(struct stat));
	result.res = fstat(argp->fh, statbuf);

	result.st_dev = statbuf->st_dev;
	result.st_ino = statbuf->st_ino;
	result.st_mode = statbuf->st_mode;
	result.st_nlink = statbuf->st_nlink;
	result.st_uid = statbuf->st_uid;
	result.st_gid = statbuf->st_gid;
	result.st_rdev = statbuf->st_rdev;
	result.st_size = statbuf->st_size;
	result.st_blksize = statbuf->st_blksize;
	result.st_blocks = statbuf->st_blocks;
	result.st_atim = statbuf->st_atime;
	result.st_mtim = statbuf->st_mtime;
	result.st_ctim = statbuf->st_ctime;

	print_fgetattr_ret_IDL(result);

	free(statbuf);
	return &result;
}

int *
mknod_1000_svc(mknod_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("mknod_1000_svc");
	static int result;

	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	int mode = argp->mode;
	int dev = argp->dev;

	if (S_ISREG(mode)) {
		result = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
		if (result >= 0){
		    result = close(result);
		}
    } else {
		if (S_ISFIFO(mode)) {
			result = mkfifo(fpath, mode);
		}
		else {
			result = mknod(fpath, mode, dev);
		}
    }

	return &result;
}
