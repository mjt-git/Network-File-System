/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#define _FILE_OFFSET_BITS  64

#include "IDL.h"
#include <stdio.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <sys/xattr.h>
#include  <fuse.h>

const char * rootpath = "/home/localadmin/finalproject/bbfs_server/serverpoint";

// typedef int(* 	fuse_fill_dir_t) (void *buf, const char *name, const struct stat *stbuf, off_t off, enum fuse_fill_dir_flags flags);

static void * getfullpath(char fpath[PATH_MAX], const char * path){
  strcpy(fpath, rootpath);
  strncat(fpath, path, PATH_MAX);
}

void print_getattr_IDL(getattr_IDL res) {
	printf("\n");
	printf("************************\n");
	printf("result.res: %d\n", res.res);
	printf("result.path: %s\n", res.path);
	printf("result.st_dev: %u\n", res.st_dev);
	printf("result.st_ino: %u\n", res.st_ino);
	printf("result.st_mode: %ld\n", res.st_mode);
	printf("result.st_nlink: %u\n", res.st_nlink);
	printf("result.st_uid: %u\n", res.st_uid);
	printf("result.st_gid: %u\n", res.st_gid);
	printf("result.st_rdev: %u\n", res.st_rdev);
	printf("result.st_size: %u\n", res.st_size);
	printf("result.st_blksize: %u\n", res.st_blksize);
	printf("result.st_blocks: %u\n", res.st_blocks);
	printf("result.st_atim: %u\n", res.st_atim);
	printf("result.st_mtim: %u\n", res.st_mtim);
	printf("result.st_ctim: %u\n", res.st_ctim);
	printf("************************\n");
	printf("\n");
}

void print_function_name(const char * name) {
	printf("\n*******************\n");
	printf("INSIDE %s\n", name);
	printf("*******************\n");
}

getattr_IDL *
getattr_1000_svc(getattr_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("getattr_10_svc");

	static getattr_IDL result;
	int res;
	struct stat * statbuf = (struct stat*)malloc(sizeof(struct stat));
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path: %s\n", argp->path);
	printf("full path is %s\n", fpath);
	res = lstat(fpath, statbuf);

	result.path = "xx";
	if(res == 0){
	  result.res = res;
	} else{
	  result.res = -errno;
	}
	result.st_dev = statbuf->st_dev;
	result.st_ino = statbuf->st_ino;
	result.st_mode = statbuf->st_mode;
	result.st_nlink = statbuf->st_nlink;
	result.st_uid = statbuf->st_uid;
	result.st_gid = statbuf->st_gid;
	result.st_rdev = statbuf->st_rdev;
	result.st_size = statbuf->st_size;
	result.st_blksize = statbuf->st_blksize;
	result.st_blocks = statbuf->st_blocks;
	result.st_atim = statbuf->st_atime;
	result.st_mtim = statbuf->st_mtime;
	result.st_ctim = statbuf->st_ctime;
	
	print_getattr_IDL(result);

	free(statbuf);
	return &result;
}

int *
mkdir_1000_svc(mkdir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("mkdir_10_svc");

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path is: %s\n", argp->path);
	//printf("argp->path_p is: %s\n", *argp->path_p);
	printf("%s, mode is %3o\n", fpath, argp->mode);
	//uint32_t fmode = argp->mode & 0777;
    result = mkdir(fpath, argp->mode);
	printf("mkdir result is: %d\n", result);
	
	return &result;
}

int *
rmdir_1000_svc(rmdir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("rmdir_10_svc");
	
	static int  result;
	char fpath[PATH_MAX];
        getfullpath(fpath, argp->path);
        printf("remove %s\n", fpath);
        //uint32_t fmode = argp->mode & 0777;                                                                    
        result = rmdir(fpath);
        printf("result is %d\n", result);

	return &result;
}

int *
open_1000_svc(open_IDL *argp, struct svc_req *rqstp)
{
	static int  result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	result = open(fpath, argp->flags);	
	/*
	 * insert server code here
	 */

	return &result;
}

struct read_IDL*
read_1000_svc(read_IDL *argp, struct svc_req *rqstp)
{
	static int  result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	char * buf;
	result = pread(argp->fh, buf, argp->size, argp->offset);
	static read_IDL res;
	res.path = "xx";
	strncpy(res.buf, buf, strlen(buf) + 1);
	
	/*
	 * insert server code here
	 */

	return &res;
}

int *
write_1000_svc(write_IDL *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */

	return &result;
}

struct opendir_ret_IDL *
opendir_1000_svc(opendir_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("opendir_1000_svc");

	static struct opendir_ret_IDL result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	DIR * dp;
	dp = opendir(fpath);
	result.isvalid = (dp == NULL) ? 0 : 1;   // 0 -> invalid; 1 -> valid
	result.res = (intptr_t)dp;

	return &result;
}

int *
readdir_1000_svc(readdir_IDL *argp, struct svc_req *rqstp)
{
	printf("[readdir_1000_svc]: start\n");
	const char * path = argp -> path;
	char * buf = argp -> buf;
	off_t offset = argp -> offset;

	static int retstat = 0;
	DIR *dp;
    struct dirent *de;

	dp = (DIR *) (uintptr_t) argp->fh;

	printf("arg->fh=%ld\n",argp->fh);
	//syscall readdir
	de = readdir(dp);
	printf("after readdir call\n");
	if (de == 0) {
        // retstat = log_error("bb_readdir readdir");
        printf("error: readdir ");
        return &retstat;
    }
    printf("before declare filler\n");
    fuse_fill_dir_t filler;
    printf("after declare filler\n");

    printf("*****de->d_d_name=%s\n",de->d_name);

	do {
        if (filler(buf, de->d_name, NULL, 0) != 0) {
            printf("calling filler with name %s\n", de->d_name);
            retstat=-ENOMEM;
            return  &retstat;
        }
    } while ((de = readdir(dp)) != NULL);

    printf("[readdir_1000_svc]: end with retstat=%d\n",retstat);
	return &retstat;
}

void *
hellotest_1000_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;
	printf("*****************************\n");
	printf("HELLO!!!!!!!!!!!!!\n");
	printf("*****************************\n");
	return (void *) &result;
}

int *
access_1000_svc(access_IDL *argp, struct svc_req *rqstp)
{
	print_function_name("access_1000_svc");

	static int result;
	char fpath[PATH_MAX];
	getfullpath(fpath, argp->path);
	printf("argp->path is: %s\n", argp->path);
	printf("fpath is: %s\n", fpath);

	result = access(fpath, argp->mask);
	printf("access function result: %d", result);
	return &result;
}
